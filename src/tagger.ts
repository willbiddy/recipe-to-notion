import { readFileSync } from "node:fs";
import { join } from "node:path";
import { fileURLToPath } from "node:url";
import Anthropic from "@anthropic-ai/sdk";
import { z } from "zod";
import type { Recipe } from "./scraper.js";

/**
 * Categorized ingredient for shopping organization.
 */
export type CategorizedIngredient = {
	/**
	 * Ingredient name/text to display. Preserves the original text from the recipe.
	 * If an ingredient appears multiple times with different contexts, include the usage
	 * context in the name (e.g. "Fine sea salt and black pepper (for marinade)").
	 */
	name: string;
	/**
	 * Shopping category (e.g. "Produce", "Dairy & Eggs", "Meat & Seafood").
	 */
	category: string;
};

/**
 * AI-generated metadata for a recipe, produced by Claude.
 */
export type RecipeTags = {
	/**
	 * Descriptive tags (2-4 items) for cuisine, dish type, and primary protein
	 * (e.g. "Italian", "Pasta", "Chicken", "Stir-Fry").
	 */
	tags: string[];
	/**
	 * Applicable meal types (e.g. "Dinner", "Snack", "Dessert").
	 */
	mealType: string[];
	/**
	 * Healthiness score from 0 (junk food) to 10 (balanced whole-food meal).
	 */
	healthiness: number;
	/**
	 * Total preparation + cooking time in minutes. Estimated by AI if not provided.
	 */
	totalTimeMinutes: number;
	/**
	 * Brief 1-2 sentence description of the dish, generated by AI.
	 */
	description: string;
	/**
	 * Ingredients categorized by shopping aisle/category.
	 * Ordered for standard grocery store flow: Produce → Meat & Seafood → Pantry → Dairy & Eggs.
	 */
	ingredients: CategorizedIngredient[];
};

/**
 * System prompt for Claude to analyze recipes and generate structured metadata.
 * Loaded from system-prompt.md file for easier editing.
 */
// Load system prompt - using readFileSync for synchronous module initialization
// Note: Bun optimizes Node.js fs operations, so readFileSync is fast even though it's Node.js API
// For async file operations elsewhere, we use Bun.file() which is even faster
const SYSTEM_PROMPT = (() => {
	const __filename = fileURLToPath(import.meta.url);
	const __dirname = join(__filename, "..");
	const promptPath = join(__dirname, "system-prompt.md");
	try {
		// Bun optimizes Node.js fs.readFileSync, so this is still fast
		return readFileSync(promptPath, "utf-8").trim();
	} catch (error) {
		throw new Error(
			`Failed to load system prompt from ${promptPath}: ${error instanceof Error ? error.message : String(error)}`,
		);
	}
})();

/**
 * Labels used when formatting recipe data into a user prompt for Claude.
 */
enum PromptLabel {
	Recipe = "Recipe",
	Description = "Source Description",
	Hints = "Source Hints (use as context, not authoritative)",
	Ingredients = "Ingredients",
	Instructions = "Instructions",
	Minutes = "Minutes",
}

/**
 * Claude model identifiers for recipe analysis.
 */
enum ClaudeModel {
	Haiku = "claude-3-5-haiku-20241022",
	Sonnet = "claude-sonnet-4-5-20250929",
	Opus = "claude-3-opus-20240229",
}

/**
 * Active Claude model to use for recipe analysis.
 * Change this to switch between models:
 * - Haiku: Fastest and cheapest (~$0.01 per recipe)
 * - Sonnet: Balanced performance and cost (~$0.03 per recipe) - Default
 * - Opus: Most capable but expensive (~$0.10+ per recipe)
 */
const ACTIVE_MODEL = ClaudeModel.Sonnet;

/**
 * Claude API configuration limits.
 */
enum ClaudeLimit {
	MaxTokens = 2048,
}

/**
 * Healthiness score configuration.
 */
enum HealthinessScore {
	Min = 0,
	Max = 10,
}

/**
 * Recipe time configuration (in minutes).
 */
enum RecipeTime {
	Min = 15,
	Max = 180,
}

/**
 * Error message display limits.
 */
enum ErrorDisplay {
	JsonParsePreview = 200,
	ValidationPreview = 300,
}

/**
 * Zod schema for validating Claude API responses.
 *
 * Validates the structure of the JSON response from Claude, ensuring
 * all required fields are present and have the correct types.
 */
const categorizedIngredientSchema = z.object({
	name: z.string().min(1, "Ingredient name is required"),
	category: z.string().min(1, "Category is required"),
});

const claudeResponseSchema = z.object({
	tags: z.array(z.string()).min(1, "At least one tag is required"),
	mealType: z.array(z.string()).min(1, "At least one meal type is required"),
	healthiness: z.number().int().min(HealthinessScore.Min).max(HealthinessScore.Max),
	totalTimeMinutes: z.number().int().positive(),
	description: z.string().min(1, "Description is required"),
	ingredients: z.array(categorizedIngredientSchema).min(1, "At least one ingredient is required"),
});

/**
 * Sends recipe data to Claude and receives tags, meal-type classifications,
 * healthiness scores, and time estimates.
 *
 * Uses Claude's tool_use API to ensure structured, validated responses.
 *
 * @param recipe - The scraped recipe to analyze.
 * @param apiKey - Anthropic API key.
 * @returns AI-generated tags and scores for the recipe.
 * @throws If the Claude API call fails, tool_use is missing, or validation fails.
 */
// biome-ignore lint/complexity/noExcessiveCognitiveComplexity: Recipe tagging logic with validation and error handling is inherently complex
export async function tagRecipe(recipe: Recipe, apiKey: string): Promise<RecipeTags> {
	const client = new Anthropic({ apiKey });

	const userMessage = buildPrompt(recipe);

	let response: Anthropic.Messages.Message;
	try {
		response = await client.messages.create({
			model: ACTIVE_MODEL,
			max_tokens: ClaudeLimit.MaxTokens,
			system: SYSTEM_PROMPT,
			tools: [
				{
					name: "tag_recipe",
					description: "Output structured recipe tags and metadata",
					input_schema: z.toJSONSchema(claudeResponseSchema) as Anthropic.Tool.InputSchema,
				},
			],
			tool_choice: { type: "tool", name: "tag_recipe" },
			messages: [{ role: "user", content: userMessage }],
		});
	} catch (error) {
		/**
		 * Handle Anthropic API errors with better error messages.
		 */
		if (error instanceof Anthropic.APIError) {
			throw new Error(
				`Anthropic API error (${error.status}): ${error.message || "Unknown error"}. ` +
					`Details: ${JSON.stringify(error.error || {})}`,
			);
		}
		/**
		 * Handle other errors (network, timeout, etc.).
		 */
		if (error instanceof Error) {
			/**
			 * Check for error cause which might contain more details.
			 */
			const causeMessage =
				error.cause && typeof error.cause === "object" && "message" in error.cause
					? String(error.cause.message)
					: undefined;
			throw new Error(
				`Failed to call Anthropic API: ${error.message}${causeMessage ? `. Cause: ${causeMessage}` : ""}`,
			);
		}
		throw new Error(`Failed to call Anthropic API: ${String(error)}`);
	}

	const toolUse = response.content.find(
		(block): block is Anthropic.Messages.ToolUseBlock => block.type === "tool_use",
	);

	if (!toolUse) {
		const textContent = response.content
			.filter((block) => block.type === "text")
			.map((block) => block.text)
			.join("");
		throw new Error(
			`Expected tool_use response from Claude, but received text instead. Response: ${textContent.substring(0, ErrorDisplay.JsonParsePreview)}...`,
		);
	}

	/**
	 * Runtime validation as a safety check (belt-and-suspenders approach).
	 */
	const validationResult = claudeResponseSchema.safeParse(toolUse.input);
	if (!validationResult.success) {
		const issues = validationResult.error.issues
			.map((issue) => {
				const path = issue.path.join(".");
				return `  - ${path}: ${issue.message}`;
			})
			.join("\n");
		throw new Error(
			`Claude tool response validation failed:\n${issues}\n\n` +
				`Tool input: ${JSON.stringify(toolUse.input).substring(0, ErrorDisplay.ValidationPreview)}...`,
		);
	}

	const validated = validationResult.data;
	const scrapedTime = recipe.totalTimeMinutes;
	const aiEstimatedTime = validated.totalTimeMinutes;

	/**
	 * Use scraped time if available, otherwise use AI estimate.
	 * Both should be validated by the schema, but we prefer scraped time.
	 */
	const finalTime = scrapedTime ?? aiEstimatedTime;

	if (finalTime === null || finalTime === undefined) {
		throw new Error(
			`Recipe time is required but was not provided. Scraped time: ${scrapedTime}, AI estimate: ${aiEstimatedTime}`,
		);
	}

	return {
		tags: validated.tags,
		mealType: validated.mealType,
		healthiness: clamp(validated.healthiness, HealthinessScore.Min, HealthinessScore.Max),
		totalTimeMinutes: clamp(finalTime, RecipeTime.Min, RecipeTime.Max),
		description: validated.description.trim(),
		ingredients: validated.ingredients,
	};
}

/**
 * Formats recipe data into a structured prompt for Claude.
 *
 * Builds a text prompt containing the recipe name, source description,
 * hints (author, cuisine, category), ingredients list, instructions,
 * and optional time information for Claude to analyze.
 *
 * @param recipe - The recipe data to format into a prompt.
 * @returns A formatted string prompt for Claude.
 */
function buildPrompt(recipe: Recipe): string {
	const lines = [`${PromptLabel.Recipe}: ${recipe.name}`];

	if (recipe.description) {
		lines.push("", `${PromptLabel.Description}: ${recipe.description}`);
	}

	/**
	 * Add hints section if any hints are available.
	 */
	const hints = buildHints(recipe);
	if (hints.length > 0) {
		lines.push("", `${PromptLabel.Hints}:`, ...hints.map((h) => `- ${h}`));
	}

	lines.push(
		"",
		`${PromptLabel.Ingredients}:`,
		...recipe.ingredients.map((i) => `- ${i}`),
		"",
		`${PromptLabel.Instructions}:`,
		...recipe.instructions.map((s, i) => `${i + 1}. ${s}`),
	);

	if (recipe.totalTimeMinutes) {
		lines.push("", `${PromptLabel.Minutes}: ${recipe.totalTimeMinutes} minutes`);
	} else {
		lines.push("", `${PromptLabel.Minutes}: not provided (please estimate)`);
	}

	return lines.join("\n");
}

/**
 * Builds a list of hint strings from available recipe metadata.
 *
 * Collects author, cuisine, and category information to provide
 * Claude with additional context for tagging decisions.
 *
 * @param recipe - The recipe with potential hint data.
 * @returns Array of hint strings, empty if no hints available.
 */
function buildHints(recipe: Recipe): string[] {
	const hints: string[] = [];
	if (recipe.author) hints.push(`Author: ${recipe.author}`);
	if (recipe.cuisine) hints.push(`Cuisine: ${recipe.cuisine}`);
	if (recipe.category) hints.push(`Category: ${recipe.category}`);
	return hints;
}

/**
 * Clamps a number to the range [min, max].
 *
 * Ensures a numeric value stays within the specified bounds by
 * returning the minimum if value is too low, or the maximum if
 * value is too high.
 *
 * @param value - The number to clamp.
 * @param min - The minimum allowed value.
 * @param max - The maximum allowed value.
 * @returns The clamped value within [min, max].
 */
function clamp(value: number, min: number, max: number): number {
	return Math.max(min, Math.min(max, value));
}
