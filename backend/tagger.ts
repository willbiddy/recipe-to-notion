import { join } from "node:path";
import { fileURLToPath } from "node:url";
import Anthropic from "@anthropic-ai/sdk";
import { z } from "zod";
import { TaggingError, ValidationError } from "./errors.js";
import type { Recipe } from "./scraper.js";

/**
 * Shopping categories for ingredient organization.
 * These categories must match exactly what Claude returns.
 */
export enum IngredientCategory {
	Produce = "Produce",
	Bakery = "Bakery",
	MeatSeafood = "Meat & seafood",
	Pantry = "Pantry",
	DairyEggs = "Dairy & eggs",
	Frozen = "Frozen",
	Other = "Other",
}

/**
 * Health score configuration.
 */
export enum HealthScore {
	Min = 1,
	Max = 10,
}

/**
 * Categorized ingredient for shopping organization.
 */
export type CategorizedIngredient = {
	/**
	 * Ingredient name/text to display. Preserves the original text from the recipe.
	 * If an ingredient appears multiple times with different contexts, include the usage
	 * context in the name (e.g. "Fine sea salt and black pepper (for marinade)").
	 */
	name: string;
	/**
	 * Shopping category. Must be one of the predefined IngredientCategory values.
	 */
	category: IngredientCategory;
};

/**
 * AI-generated metadata for a recipe, produced by Claude.
 */
export type RecipeTags = {
	/**
	 * Descriptive tags (2-4 items) for cuisine, dish type, and primary protein
	 * (e.g. "Italian", "Pasta", "Chicken", "Stir-Fry").
	 */
	tags: string[];
	/**
	 * Applicable meal types (e.g. "Dinner", "Snack", "Dessert").
	 */
	mealType: string[];
	/**
	 * Health score from 1 (junk food) to 10 (balanced whole-food meal).
	 */
	healthScore: number;
	/**
	 * Total preparation + cooking time in minutes. Estimated by AI if not provided.
	 */
	totalTimeMinutes: number;
	/**
	 * Brief 1-2 sentence description of the dish, generated by AI.
	 */
	description: string;
	/**
	 * Ingredients categorized by shopping aisle/category.
	 * Ordered for standard grocery store flow: Produce → Bakery → Meat & seafood → Pantry → Dairy & eggs → Frozen → Other.
	 */
	ingredients: CategorizedIngredient[];
};

/**
 * Labels used when formatting recipe data into a user prompt for Claude.
 */
enum PromptLabel {
	Recipe = "Recipe",
	Description = "Description",
	Hints = "Hints",
	Ingredients = "Ingredients",
	Instructions = "Instructions",
	Minutes = "Minutes",
}

/**
 * Claude model identifiers for recipe analysis.
 */
enum ClaudeModel {
	Haiku = "claude-3-5-haiku-20241022",
	Sonnet = "claude-sonnet-4-5-20250929",
	Opus = "claude-3-opus-20240229",
}

/**
 * Gets the Claude model from environment variable or defaults to Sonnet.
 *
 * Set CLAUDE_MODEL environment variable to one of: "haiku", "sonnet", or "opus".
 * Defaults to "sonnet" if not set or invalid.
 *
 * Model costs (approximate):
 * - Haiku: Fastest and cheapest (~$0.01 per recipe)
 * - Sonnet: Balanced performance and cost (~$0.03 per recipe) - Default
 * - Opus: Most capable but expensive (~$0.10+ per recipe)
 *
 * @returns The Claude model identifier to use.
 */
function getClaudeModel(): ClaudeModel {
	const envModel = process.env.CLAUDE_MODEL?.toLowerCase();

	switch (envModel) {
		case "haiku":
			return ClaudeModel.Haiku;
		case "sonnet":
			return ClaudeModel.Sonnet;
		case "opus":
			return ClaudeModel.Opus;
		default:
			return ClaudeModel.Sonnet;
	}
}

const CLAUDE_MODEL = getClaudeModel();

/**
 * Claude API configuration limits.
 */
enum ClaudeLimit {
	MaxTokens = 2048,
}

/**
 * Recipe time configuration (in minutes).
 * Allows for quick no-cook recipes (5 min) and slow-cooked dishes (8 hours).
 */
enum RecipeTime {
	Min = 5,
	Max = 480,
}

/**
 * Error message display limits.
 */
enum ErrorDisplay {
	JsonParsePreview = 200,
	ValidationPreview = 300,
}

/**
 * Zod schema for validating Claude API responses.
 * Validates the structure of the JSON response from Claude, ensuring
 * all required fields are present and have the correct types.
 */
const categorizedIngredientSchema = z.object({
	name: z.string().min(1, "Ingredient name is required"),
	category: z.nativeEnum(IngredientCategory, {
		message: `Category must be one of: ${Object.values(IngredientCategory).join(", ")}`,
	}),
});

const claudeResponseSchema = z.object({
	tags: z.array(z.string()).min(1, "At least one tag is required"),
	mealType: z.array(z.string()).min(1, "At least one meal type is required"),
	healthScore: z.number().int().min(HealthScore.Min).max(HealthScore.Max),
	totalTimeMinutes: z.number().int().positive(),
	description: z.string().min(1, "Description is required"),
	ingredients: z.array(categorizedIngredientSchema).min(1, "At least one ingredient is required"),
});

let systemPromptCache: string | null = null;

/**
 * Loads the system prompt from the file system.
 * Uses Bun's native file API for optimal performance.
 * Caches the result after first load.
 *
 * @returns The system prompt text.
 * @throws If the file cannot be read.
 */
async function loadSystemPrompt(): Promise<string> {
	if (systemPromptCache !== null) {
		return systemPromptCache;
	}

	const __filename = fileURLToPath(import.meta.url);
	const __dirname = join(__filename, "..");
	const promptPath = join(__dirname, "system-prompt.md");

	try {
		const file = Bun.file(promptPath);
		const text = await file.text();
		systemPromptCache = text.trim();
		return systemPromptCache;
	} catch (error) {
		throw new TaggingError(
			`Failed to load system prompt from ${promptPath}: ${error instanceof Error ? error.message : String(error)}`,
			error,
		);
	}
}

/**
 * Sends recipe data to Claude and receives tags, meal-type classifications,
 * health scores, and time estimates.
 *
 * Uses Claude's tool_use API to ensure structured, validated responses.
 *
 * @param recipe - The scraped recipe to analyze.
 * @param apiKey - Anthropic API key.
 * @returns AI-generated tags and scores for the recipe.
 * @throws If the Claude API call fails, tool_use is missing, or validation fails.
 */
export async function tagRecipe(recipe: Recipe, apiKey: string): Promise<RecipeTags> {
	const client = new Anthropic({ apiKey });
	const userMessage = buildPrompt(recipe);
	const systemPrompt = await loadSystemPrompt();

	const response = await callClaudeAPI(client, userMessage, systemPrompt);
	const toolUse = extractToolUse(response);
	const validated = validateClaudeResponse(toolUse);
	const totalTime = recipe.totalTimeMinutes ?? validated.totalTimeMinutes;

	return {
		tags: validated.tags,
		mealType: validated.mealType,
		healthScore: clamp(validated.healthScore, HealthScore.Min, HealthScore.Max),
		totalTimeMinutes: clamp(totalTime, RecipeTime.Min, RecipeTime.Max),
		description: validated.description.trim(),
		ingredients: validated.ingredients,
	};
}

/**
 * Calls the Claude API with the recipe prompt.
 */
async function callClaudeAPI(
	client: Anthropic,
	userMessage: string,
	systemPrompt: string,
): Promise<Anthropic.Messages.Message> {
	try {
		return await client.messages.create({
			model: CLAUDE_MODEL,
			max_tokens: ClaudeLimit.MaxTokens,
			system: systemPrompt,
			tools: [
				{
					name: "tag_recipe",
					description: "Output structured recipe tags and metadata",
					input_schema: z.toJSONSchema(claudeResponseSchema) as Anthropic.Tool.InputSchema,
				},
			],
			tool_choice: { type: "tool", name: "tag_recipe" },
			messages: [{ role: "user", content: userMessage }],
		});
	} catch (error) {
		if (error instanceof Anthropic.APIError) {
			throw new TaggingError(
				`Anthropic API error (${error.status}): ${error.message || "Unknown error"}. ` +
					`Details: ${JSON.stringify(error.error || {})}`,
				error,
			);
		}

		const errorMessage = error instanceof Error ? error.message : String(error);

		const causeMessage =
			error instanceof Error &&
			error.cause &&
			typeof error.cause === "object" &&
			"message" in error.cause
				? String(error.cause.message)
				: undefined;

		throw new TaggingError(
			`Failed to call Anthropic API: ${errorMessage}${causeMessage ? `. Cause: ${causeMessage}` : ""}`,
			error instanceof Error ? error : new Error(String(error)),
		);
	}
}

/**
 * Extracts the tool_use block from Claude's response.
 */
function extractToolUse(response: Anthropic.Messages.Message): Anthropic.Messages.ToolUseBlock {
	const toolUse = response.content.find(
		(block): block is Anthropic.Messages.ToolUseBlock => block.type === "tool_use",
	);

	if (!toolUse) {
		const textContent = response.content
			.filter((block) => block.type === "text")
			.map((block) => block.text)
			.join("");
		throw new TaggingError(
			`Expected tool_use response from Claude, but received text instead. Response: ${textContent.substring(0, ErrorDisplay.JsonParsePreview)}...`,
		);
	}

	return toolUse;
}

/**
 * Validates Claude's tool response against the expected schema.
 */
function validateClaudeResponse(
	toolUse: Anthropic.Messages.ToolUseBlock,
): z.infer<typeof claudeResponseSchema> {
	const validationResult = claudeResponseSchema.safeParse(toolUse.input);

	if (!validationResult.success) {
		const issues = validationResult.error.issues
			.map((issue) => {
				const path = issue.path.join(".");
				return `  - ${path}: ${issue.message}`;
			})
			.join("\n");
		throw new ValidationError(
			`Claude tool response validation failed:\n${issues}\n\n` +
				`Tool input: ${JSON.stringify(toolUse.input).substring(0, ErrorDisplay.ValidationPreview)}...`,
			validationResult.error,
		);
	}

	return validationResult.data;
}

/**
 * Formats recipe data into a structured prompt for Claude.
 * Builds a text prompt containing the recipe name, source description,
 * hints (author, cuisine, category), ingredients list, instructions,
 * and optional time information for Claude to analyze.
 */
function buildPrompt(recipe: Recipe): string {
	const lines = [`${PromptLabel.Recipe}: ${recipe.name}`];

	if (recipe.description) {
		lines.push("", `${PromptLabel.Description}: ${recipe.description}`);
	}

	const hints = buildHints(recipe);
	if (hints.length > 0) {
		lines.push("", `${PromptLabel.Hints}:`, ...hints.map((h) => `- ${h}`));
	}

	lines.push(
		"",
		`${PromptLabel.Ingredients}:`,
		...recipe.ingredients.map((i) => `- ${i}`),
		"",
		`${PromptLabel.Instructions}:`,
		...recipe.instructions.map((s, i) => `${i + 1}. ${s}`),
	);

	if (recipe.totalTimeMinutes) {
		lines.push("", `${PromptLabel.Minutes}: ${recipe.totalTimeMinutes} minutes`);
	}

	return lines.join("\n");
}

/**
 * Builds a list of hint strings from available recipe metadata.
 * Collects author, cuisine, and category information to provide
 * Claude with additional context for tagging decisions.
 */
function buildHints(recipe: Recipe): string[] {
	const hints: string[] = [];

	if (recipe.author) hints.push(`Author: ${recipe.author}`);
	if (recipe.cuisine) hints.push(`Cuisine: ${recipe.cuisine}`);
	if (recipe.category) hints.push(`Category: ${recipe.category}`);

	return hints;
}

/**
 * Clamps a number to the range [min, max].
 * Ensures a numeric value stays within the specified bounds by
 * returning the minimum if value is too low, or the maximum if
 * value is too high.
 */
function clamp(value: number, min: number, max: number): number {
	return Math.max(min, Math.min(max, value));
}
