import { readFileSync } from "node:fs";
import { join } from "node:path";
import { fileURLToPath } from "node:url";
import Anthropic from "@anthropic-ai/sdk";
import { z } from "zod";
import type { Recipe } from "./scraper.js";

/**
 * AI-generated metadata for a recipe, produced by Claude.
 */
export interface RecipeTags {
	/**
	 * Descriptive tags (2-4 items) for cuisine, dish type, and primary protein
	 * (e.g. "Italian", "Pasta", "Chicken", "Stir-Fry").
	 */
	tags: string[];
	/**
	 * Applicable meal types (e.g. "Dinner", "Snack", "Dessert").
	 */
	mealType: string[];
	/**
	 * Healthiness score from 0 (junk food) to 10 (balanced whole-food meal).
	 */
	healthiness: number;
	/**
	 * Total preparation + cooking time in minutes. Estimated by AI if not provided.
	 */
	totalTimeMinutes: number;
	/**
	 * Brief 1-2 sentence description of the dish, generated by AI.
	 */
	description: string;
}

/**
 * System prompt for Claude to analyze recipes and generate structured metadata.
 * Loaded from system-prompt.md file for easier editing.
 */
const SYSTEM_PROMPT = (() => {
	const __filename = fileURLToPath(import.meta.url);
	const __dirname = join(__filename, "..");
	const promptPath = join(__dirname, "system-prompt.md");
	try {
		return readFileSync(promptPath, "utf-8").trim();
	} catch (error) {
		throw new Error(
			`Failed to load system prompt from ${promptPath}: ${error instanceof Error ? error.message : String(error)}`,
		);
	}
})();

/**
 * Labels used when formatting recipe data into a user prompt for Claude.
 */
enum PromptLabel {
	Recipe = "Recipe",
	Description = "Source Description",
	Hints = "Source Hints (use as context, not authoritative)",
	Ingredients = "Ingredients",
	Instructions = "Instructions",
	Minutes = "Minutes",
}

/**
 * Claude model identifier for recipe analysis.
 */
enum ClaudeModel {
	Sonnet = "claude-sonnet-4-5-20250929",
}

/**
 * Claude API configuration limits.
 */
enum ClaudeLimit {
	MaxTokens = 1024,
}

/**
 * Healthiness score configuration.
 */
enum HealthinessScore {
	Min = 0,
	Max = 10,
}

/**
 * Recipe time configuration (in minutes).
 */
enum RecipeTime {
	Min = 15,
	Max = 180,
}

/**
 * Error message display limits.
 */
enum ErrorDisplay {
	JsonParsePreview = 200,
	ValidationPreview = 300,
}

/**
 * Zod schema for validating Claude API responses.
 *
 * Validates the structure of the JSON response from Claude, ensuring
 * all required fields are present and have the correct types.
 */
const claudeResponseSchema = z.object({
	tags: z.array(z.string()).min(1, "At least one tag is required"),
	mealType: z.array(z.string()).min(1, "At least one meal type is required"),
	healthiness: z
		.number()
		.int()
		.min(HealthinessScore.Min)
		.max(HealthinessScore.Max),
	totalTimeMinutes: z.number().int().positive(),
	description: z.string().min(1, "Description is required"),
});

/**
 * Sends recipe data to Claude and receives tags, meal-type classifications,
 * healthiness scores, and time estimates.
 *
 * @param recipe - The scraped recipe to analyze.
 * @param apiKey - Anthropic API key.
 * @returns AI-generated tags and scores for the recipe.
 * @throws If the Claude API call fails or returns unparseable JSON.
 */
export async function tagRecipe(
	recipe: Recipe,
	apiKey: string,
): Promise<RecipeTags> {
	const client = new Anthropic({ apiKey });

	const userMessage = buildPrompt(recipe);

	const response = await client.messages.create({
		model: ClaudeModel.Sonnet,
		max_tokens: ClaudeLimit.MaxTokens,
		system: SYSTEM_PROMPT,
		messages: [{ role: "user", content: userMessage }],
	});

	const text = response.content
		.filter((block) => block.type === "text")
		.map((block) => block.text)
		.join("");

	let parsed: unknown;
	try {
		const cleanedText = stripMarkdownCodeBlocks(text);
		parsed = JSON.parse(cleanedText);
	} catch (error) {
		throw new Error(
			`Failed to parse Claude response as JSON. Response: ${text.substring(0, ErrorDisplay.JsonParsePreview)}...\n` +
				`Parse error: ${error instanceof Error ? error.message : String(error)}`,
		);
	}

	const validationResult = claudeResponseSchema.safeParse(parsed);
	if (!validationResult.success) {
		const issues = validationResult.error.issues
			.map((issue) => {
				const path = issue.path.join(".");
				return `  - ${path}: ${issue.message}`;
			})
			.join("\n");
		throw new Error(
			`Claude response validation failed:\n${issues}\n\n` +
				`Raw response: ${text.substring(0, ErrorDisplay.ValidationPreview)}...`,
		);
	}

	const validated = validationResult.data;
	const scrapedTime = recipe.totalTimeMinutes;
	const aiEstimatedTime = validated.totalTimeMinutes;

	// Use scraped time if available, otherwise use AI estimate
	// Both should be validated by the schema, but we prefer scraped time
	const finalTime = scrapedTime ?? aiEstimatedTime;

	if (finalTime === null || finalTime === undefined) {
		throw new Error(
			`Recipe time is required but was not provided. Scraped time: ${scrapedTime}, AI estimate: ${aiEstimatedTime}`,
		);
	}

	return {
		tags: validated.tags,
		mealType: validated.mealType,
		healthiness: clamp(
			validated.healthiness,
			HealthinessScore.Min,
			HealthinessScore.Max,
		),
		totalTimeMinutes: clamp(finalTime, RecipeTime.Min, RecipeTime.Max),
		description: validated.description.trim(),
	};
}

/**
 * Formats recipe data into a structured prompt for Claude.
 *
 * Builds a text prompt containing the recipe name, source description,
 * hints (author, cuisine, category), ingredients list, instructions,
 * and optional time information for Claude to analyze.
 *
 * @param recipe - The recipe data to format into a prompt.
 * @returns A formatted string prompt for Claude.
 */
function buildPrompt(recipe: Recipe): string {
	const lines = [`${PromptLabel.Recipe}: ${recipe.name}`];

	if (recipe.description) {
		lines.push("", `${PromptLabel.Description}: ${recipe.description}`);
	}

	// Add hints section if any hints are available
	const hints = buildHints(recipe);
	if (hints.length > 0) {
		lines.push("", `${PromptLabel.Hints}:`, ...hints.map((h) => `- ${h}`));
	}

	lines.push(
		"",
		`${PromptLabel.Ingredients}:`,
		...recipe.ingredients.map((i) => `- ${i}`),
		"",
		`${PromptLabel.Instructions}:`,
		...recipe.instructions.map((s, i) => `${i + 1}. ${s}`),
	);

	if (recipe.totalTimeMinutes) {
		lines.push(
			"",
			`${PromptLabel.Minutes}: ${recipe.totalTimeMinutes} minutes`,
		);
	} else {
		lines.push("", `${PromptLabel.Minutes}: not provided (please estimate)`);
	}

	return lines.join("\n");
}

/**
 * Builds a list of hint strings from available recipe metadata.
 *
 * Collects author, cuisine, and category information to provide
 * Claude with additional context for tagging decisions.
 *
 * @param recipe - The recipe with potential hint data.
 * @returns Array of hint strings, empty if no hints available.
 */
function buildHints(recipe: Recipe): string[] {
	const hints: string[] = [];
	if (recipe.author) hints.push(`Author: ${recipe.author}`);
	if (recipe.cuisine) hints.push(`Cuisine: ${recipe.cuisine}`);
	if (recipe.category) hints.push(`Category: ${recipe.category}`);
	return hints;
}

/**
 * Strips markdown code blocks from text (handles ```json, ```, etc.).
 *
 * This is needed because Claude sometimes wraps JSON responses in
 * markdown code blocks. Removes the code fence markers to extract
 * the raw JSON content. Also handles incomplete responses where
 * only the opening fence is present.
 *
 * @param text - The text that may contain markdown code blocks.
 * @returns The text with code block markers removed.
 */
function stripMarkdownCodeBlocks(text: string): string {
	let cleaned = text.trim();

	// Remove opening code fence (```json or ```)
	cleaned = cleaned.replace(/^```(?:json)?\s*\n?/, "");

	// Remove closing code fence
	cleaned = cleaned.replace(/\n?```\s*$/, "");

	return cleaned.trim();
}

/**
 * Clamps a number to the range [min, max].
 *
 * Ensures a numeric value stays within the specified bounds by
 * returning the minimum if value is too low, or the maximum if
 * value is too high.
 *
 * @param value - The number to clamp.
 * @param min - The minimum allowed value.
 * @param max - The maximum allowed value.
 * @returns The clamped value within [min, max].
 */
function clamp(value: number, min: number, max: number): number {
	return Math.max(min, Math.min(max, value));
}
